---
import Layout from "../layouts/Layout.astro";
---

<Layout title="EQRng.com - Random Zone Generator" currentPage="zone">
    <div class="max-w-4xl mx-auto px-4 py-8">
        <div id="result" class="mb-6 transition-opacity duration-300"></div>
        <div
            class="bg-slate-800 rounded-lg shadow-xl border border-slate-600/20 p-6"
        >
            <h1 class="text-3xl font-bold text-white mb-6">
                Random EverQuest Zone
            </h1>

            <div class="grid grid-cols-4 gap-4 mb-6">
                <div>
                    <label
                        class="block text-sm font-medium text-slate-300 mb-2"
                    >
                        Min Level
                    </label>
                    <input
                        type="number"
                        id="min"
                        min="1"
                        max="125"
                        placeholder="Any"
                        class="w-full p-2 bg-slate-700 border border-slate-600 text-white rounded-md focus:ring-blue-400 focus:border-blue-400"
                    />
                </div>

                <div>
                    <label
                        class="block text-sm font-medium text-slate-300 mb-2"
                    >
                        Max Level
                    </label>
                    <input
                        type="number"
                        id="max"
                        min="1"
                        max="125"
                        placeholder="Any"
                        class="w-full p-2 bg-slate-700 border border-slate-600 text-white rounded-md focus:ring-blue-400 focus:border-blue-400"
                    />
                </div>

                <div class="col-span-2">
                    <label
                        class="block text-sm font-medium text-slate-300 mb-2"
                    >
                        Expansion
                    </label>
                    <select
                        id="expansion"
                        class="w-full p-2 bg-slate-700 border border-slate-600 text-white rounded-md focus:ring-blue-400 focus:border-blue-400"
                    >
                        <option value="">Any</option>
                        <option>Classic</option>
                        <option>Kunark</option>
                        <option>Velious</option>
                        <option>Shadows of Luclin</option>
                        <option>Planes of Power</option>
                        <option>The Legacy of Ykesha</option>
                        <option>Lost Dungeons of Norrath</option>
                        <option>Gates of Discord</option>
                        <option>Omens of War</option>
                        <option>Dragons of Norrath</option>
                        <option>Depths of Darkhollow</option>
                        <option>Prophecy of Ro</option>
                        <option>The Serpent's Spine</option>
                        <option>The Buried Sea</option>
                        <option>Secrets of Faydwer</option>
                        <option>Seeds of Destruction</option>
                        <option>Underfoot</option>
                        <option>House of Thule</option>
                        <option>Veil of Alaris</option>
                        <option>Rain of Fear</option>
                        <option>Call of the Forsaken</option>
                        <option>The Darkened Sea</option>
                        <option>The Broken Mirror</option>
                        <option>Empires of Kunark</option>
                        <option>Ring of Scale</option>
                        <option>The Burning Lands</option>
                        <option>Torment of Velious</option>
                        <option>Claws of Veeshan</option>
                        <option>Terror of Luclin</option>
                        <option>Night of Shadows</option>
                        <option>Laurion's Song</option>
                        <option>The Outer Brood</option>
                    </select>
                </div>
            </div>

            <!-- Zone Flags Filter -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-slate-300 mb-3">
                    Zone Flags (optional - check to filter by specific flags)
                </label>
                <div
                    id="flag-checkboxes"
                    class="grid grid-cols-2 sm:grid-cols-3 gap-3"
                >
                    <!-- Flag checkboxes will be dynamically loaded here -->
                </div>
            </div>

            <button
                id="generate-zone"
                class="w-full bg-blue-600 hover:bg-blue-500 text-white font-medium py-3 px-4 rounded-md transition-colors shadow-lg"
            >
                Generate Random Zone
            </button>
        </div>
    </div>

    <script>
        // Helper: extract YouTube ID from common URL forms
        function extractYouTubeId(href) {
            if (!href || typeof href !== "string") return null;
            const match = href.match(
                /(?:https?:\/\/)?(?:(?:www|m)\.)?(?:youtu\.be\/|youtube\.com\/(?:watch\?v=|embed\/|shorts\/))([A-Za-z0-9_-]{11})/,
            );
            return match ? match[1] : null;
        }

        // Build a clickable thumbnail element for a YouTube video id
        function createYouTubeThumbnail(videoId) {
            const wrapper = document.createElement("div");
            wrapper.className = "inline-block video-thumb-wrapper";
            wrapper.style.display = "inline-block";
            wrapper.style.marginLeft = "8px";
            wrapper.style.verticalAlign = "middle";
            wrapper.style.cursor = "pointer";
            wrapper.style.width = "240px";
            wrapper.style.height = "135px";
            wrapper.style.position = "relative";
            wrapper.style.overflow = "hidden";
            wrapper.style.borderRadius = "6px";
            wrapper.style.boxShadow = "0 2px 8px rgba(0,0,0,0.4)";
            wrapper.style.flex = "none";

            const img = document.createElement("img");
            // use higher-quality thumbnail (240x135)
            img.src = `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;
            img.alt = "YouTube thumbnail";
            img.style.width = "100%";
            img.style.height = "100%";
            img.style.objectFit = "cover";
            img.loading = "lazy";
            wrapper.appendChild(img);

            // play button overlay
            const play = document.createElement("div");
            play.style.position = "absolute";
            play.style.left = "50%";
            play.style.top = "50%";
            play.style.transform = "translate(-50%, -50%)";
            play.style.width = "52px";
            play.style.height = "52px";
            play.style.borderRadius = "50%";
            play.style.background = "rgba(0,0,0,0.6)";
            play.style.display = "flex";
            play.style.alignItems = "center";
            play.style.justifyContent = "center";
            play.style.boxShadow = "0 2px 6px rgba(0,0,0,0.5)";
            play.innerHTML = `<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7L8 5z" fill="white"/></svg>`;
            wrapper.appendChild(play);

            // click-to-load iframe (no autoplay)
            wrapper.addEventListener("click", () => {
                const iframe = document.createElement("iframe");
                iframe.width = "480";
                iframe.height = "270";
                iframe.src = `https://www.youtube.com/embed/${videoId}?rel=0&modestbranding=1`;
                iframe.frameBorder = "0";
                iframe.setAttribute(
                    "allow",
                    "accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture",
                );
                iframe.allowFullscreen = true;
                iframe.style.borderRadius = "6px";
                iframe.style.maxWidth = "100%";
                iframe.loading = "lazy";

                // replace wrapper with iframe but keep container sizing reasonable
                const container = document.createElement("div");
                container.style.display = "inline-block";
                container.style.marginLeft = "8px";
                container.style.verticalAlign = "middle";
                container.appendChild(iframe);

                wrapper.replaceWith(container);
            });

            return wrapper;
        }

        // Function to load flag types from API and generate checkboxes
        async function loadFlagTypes() {
            try {
                const response = await fetch("/flag-types");
                if (!response.ok) {
                    console.error("Failed to load flag types");
                    return;
                }

                const flagTypes = await response.json();
                const container = document.getElementById(
                    "flag-checkboxes",
                ) as HTMLElement | null;

                if (!container) return;

                // Define emoji mapping for flag types
                const emojiMap = {
                    hot_zone: "🔥",
                    undead: "💀",
                    epic_zone: "⚔️",
                    newbie_friendly: "🌱",
                    raid_zone: "🏰",
                    pvp_zone: "⚔️",
                };

                // Function to extract color from color_class
                const getColorFromClass = (colorClass) => {
                    // Extract color from "bg-COLOR-500" format
                    const match = colorClass.match(/bg-(\w+)-500/);
                    return match ? match[1] : "blue";
                };

                // Generate checkboxes dynamically
                container.innerHTML = flagTypes
                    .map((flagType) => {
                        const emoji = emojiMap[flagType.name] || "🔸";
                        const color = getColorFromClass(flagType.color_class);

                        return `
                        <label class="flex items-center space-x-2 cursor-pointer">
                            <input
                                type="checkbox"
                                id="flag-${flagType.name}"
                                value="${flagType.name}"
                                class="w-4 h-4 text-${color}-600 bg-slate-700 border-slate-600 rounded focus:ring-${color}-500 focus:ring-2"
                            />
                            <span class="text-sm text-slate-300">${emoji} ${flagType.display_name}</span>
                        </label>
                    `;
                    })
                    .join("");
            } catch (error) {
                console.error("Error loading flag types:", error);
            }
        }

        // Load flag types when page loads
        document.addEventListener("DOMContentLoaded", loadFlagTypes);

        // Generate zone handler
        async function generateZone(forceFlag = null) {
            const params = new URLSearchParams();
            const minElement = document.getElementById(
                "min",
            ) as HTMLInputElement | null;
            const maxElement = document.getElementById(
                "max",
            ) as HTMLInputElement | null;
            const expansionElement = document.getElementById(
                "expansion",
            ) as HTMLSelectElement | null;

            const min = minElement?.value || "";
            const max = maxElement?.value || "";
            const expansion = expansionElement?.value || "";

            // Get selected flags
            const selectedFlags: string[] = [];
            const flagCheckboxes = document.querySelectorAll<HTMLInputElement>(
                'input[type="checkbox"][id^="flag-"]:checked',
            );
            for (const checkbox of flagCheckboxes) {
                selectedFlags.push(checkbox.value);
            }

            const resultDiv = document.getElementById(
                "result",
            ) as HTMLElement | null;
            if (!resultDiv) return;

            // Validate level inputs
            if (
                min &&
                (parseInt(min) < 1 ||
                    parseInt(min) > 125 ||
                    isNaN(parseInt(min)))
            ) {
                resultDiv.innerHTML =
                    '<div class="bg-red-900/50 border border-red-600 text-red-200 px-4 py-3 rounded">Min level must be between 1 and 125.</div>';
                return;
            }

            if (
                max &&
                (parseInt(max) < 1 ||
                    parseInt(max) > 125 ||
                    isNaN(parseInt(max)))
            ) {
                resultDiv.innerHTML =
                    '<div class="bg-red-900/50 border border-red-600 text-red-200 px-4 py-3 rounded">Max level must be between 1 and 125.</div>';
                return;
            }

            if (min && max && parseInt(min) > parseInt(max)) {
                resultDiv.innerHTML =
                    '<div class="bg-red-900/50 border border-red-600 text-red-200 px-4 py-3 rounded">Min level cannot be greater than max level.</div>';
                return;
            }

            // Set parameters
            if (min) params.set("min", min);
            if (max) params.set("max", max);
            if (expansion) params.set("expansion", expansion);

            // Handle flag filtering
            if (forceFlag) {
                params.set("flags", forceFlag);
            } else if (selectedFlags.length > 0) {
                params.set("flags", selectedFlags.join(","));
            }

            params.set("mission", "false"); // Always exclude mission zones

            // Add loading state with smooth transition
            resultDiv.style.opacity = "0.5";
            const originalContent = resultDiv.innerHTML;

            try {
                // Add cache-busting timestamp to ensure fresh data
                params.set("_t", Date.now().toString());
                console.log(`Fetching zone data: /random_zone?${params}`);
                const response = await fetch(`/random_zone?${params}`, {
                    cache: "no-store",
                    headers: {
                        "Cache-Control": "no-cache",
                    },
                });

                if (!response.ok) {
                    resultDiv.style.opacity = "1";
                    resultDiv.innerHTML =
                        '<div class="bg-red-900/50 border border-red-600 text-red-200 px-4 py-3 rounded">No zones found matching your criteria.</div>';
                    return;
                }

                const zone = await response.json();

                // Function to convert backend color classes to Tailwind colors
                const getColorClasses = (colorClass) => {
                    const colorMap = {
                        "bg-red-500": "bg-red-500 border-red-400",
                        "bg-orange-500": "bg-orange-500 border-orange-400",
                        "bg-yellow-500": "bg-yellow-500 border-yellow-400",
                        "bg-green-500": "bg-green-500 border-green-400",
                        "bg-blue-500": "bg-blue-500 border-blue-400",
                        "bg-indigo-500": "bg-indigo-500 border-indigo-400",
                        "bg-purple-500": "bg-purple-500 border-purple-400",
                        "bg-pink-500": "bg-pink-500 border-pink-400",
                        "bg-gray-500": "bg-gray-500 border-gray-400",
                        "bg-slate-500": "bg-slate-500 border-slate-400",
                        "bg-cyan-500": "bg-cyan-500 border-cyan-400",
                        "bg-teal-500": "bg-teal-500 border-teal-400",
                        "bg-emerald-500": "bg-emerald-500 border-emerald-400",
                        "bg-lime-500": "bg-lime-500 border-lime-400",
                        "bg-amber-500": "bg-amber-500 border-amber-400",
                        "bg-rose-500": "bg-rose-500 border-rose-400",
                        "bg-fuchsia-500": "bg-fuchsia-500 border-fuchsia-400",
                        "bg-violet-500": "bg-violet-500 border-violet-400",
                    };
                    return (
                        colorMap[colorClass] || "bg-gray-500 border-gray-400"
                    );
                };

                // Generate flag pills HTML
                const flagPillsHTML =
                    zone.flags && zone.flags.length > 0
                        ? `
                    <div class="mt-6 pt-4 border-t border-slate-600 mb-4">
                        <div class="font-medium mb-2 text-slate-300">Zone Flags:</div>
                        <div class="flex flex-wrap gap-2">
                            ${zone.flags
                                .map((flag) => {
                                    const colors = getColorClasses(
                                        flag.flag_type?.color_class,
                                    );
                                    return `<span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium text-white border ${colors}">${flag.flag_type?.display_name || "Unknown"}</span>`;
                                })
                                .join("")}
                        </div>
                    </div>
                    `
                        : "";

                // Build the zone card HTML. Place notes placeholder at the BOTTOM of the card (after flags).
                resultDiv.innerHTML = `
        <div class="bg-slate-700 border border-slate-600 rounded-lg p-6" id="zone-details">
          <h2 class="text-4xl font-bold text-white mb-4">${zone.name}</h2>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-base">
            <div class="flex justify-between"><span class="font-medium text-slate-300">Levels:</span> <span class="text-white">${zone.level_ranges.map((r) => r.join("–")).join(", ")}</span></div>
            <div class="flex justify-between"><span class="font-medium text-slate-300">Expansion:</span> <span class="text-white">${zone.expansion}</span></div>
            <div class="flex justify-between"><span class="font-medium text-slate-300">Continent:</span> <span class="text-white">${zone.continent || "Unknown"}</span></div>
            <div class="flex justify-between"><span class="font-medium text-slate-300">Type:</span> <span class="text-white">${zone.zone_type}</span></div>

            <div class="flex justify-between items-center"><span class="font-medium text-slate-300">Verified:</span> <img src="/assets/images/gouda.png" alt="Verified" class="w-6 h-6 ${zone.verified ? "opacity-100" : "opacity-30"}" /></div>
          </div>
          ${
              zone.connections.length > 0
                  ? `
            <div class="mt-4 pt-4 border-t border-slate-600">
              <div class="font-medium mb-2 text-slate-300">Connections:</div>
              <div class="text-base text-white">${zone.connections.join(", ")}</div>
            </div>
          `
                  : ""
          }

          <div class="mt-6 pt-4 border-t border-slate-600">
            <div class="font-medium mb-3 text-slate-300">Rate this zone:</div>
            <div id="rating-container-${zone.id}" class="rating-container" data-zone-id="${zone.id}">
              <div class="flex items-center gap-1 mb-2">
                ${Array.from(
                    { length: 5 },
                    (_, i) => `
                  <button class="pickle-rating" data-rating="${i + 1}">
                    <img src="/assets/images/pickle.png" alt="Pickle ${i + 1}" class="w-6 h-6 pickle-icon opacity-30 hover:opacity-100 transition-opacity duration-200" />
                  </button>
                `,
                ).join("")}
              </div>
              <div class="rating-stats text-base text-slate-400">
                <span id="rating-text-${zone.id}">Loading ratings...</span>
              </div>
            </div>
          </div>

          ${flagPillsHTML}

          <!-- Notes will be inserted here at the BOTTOM of the card -->
          <div id="zone-notes-${zone.id}" class="mt-4 pt-4 border-t border-slate-600"></div>

        </div>
      `;

                // Smooth transition to new content
                resultDiv.style.opacity = "1";

                // Load zone rating and display notes (notes may be included in the zone response)
                loadZoneRating(zone.id);
                // If zone.notes provided from server use them, otherwise fetch
                if (zone.notes && zone.notes.length > 0) {
                    displayZoneNotes(zone.id, zone.notes);
                } else {
                    loadZoneNotes(zone.id);
                }
            } catch (error) {
                console.error("Error fetching zone:", error);
                resultDiv.style.opacity = "1";
                resultDiv.innerHTML =
                    '<div class="bg-red-900/50 border border-red-600 text-red-200 px-4 py-3 rounded">Error loading zone. Please try again.</div>';
            }
        }

        const generateButton = document.getElementById(
            "generate-zone",
        ) as HTMLButtonElement | null;
        if (generateButton) {
            generateButton.onclick = async () => {
                await generateZone();
            };
        }

        // Function to load and display zone notes
        async function loadZoneNotes(zoneId) {
            console.log("loadZoneNotes: called for zoneId =", zoneId);
            try {
                const response = await fetch(`/zones/${zoneId}/notes`);
                console.log(
                    "loadZoneNotes: fetch completed, ok =",
                    response.ok,
                    "status =",
                    response.status,
                );
                if (response.ok) {
                    const notes = await response.json();
                    console.log("loadZoneNotes: received notes:", notes);
                    displayZoneNotes(zoneId, notes);
                } else {
                    console.warn(
                        "loadZoneNotes: response not ok for zoneId",
                        zoneId,
                    );
                }
            } catch (error) {
                console.error("Error loading zone notes:", error);
            }
        }

        // Function to display zone notes — inserts into placeholder at bottom of the card
        function displayZoneNotes(zoneId, notes) {
            if (!notes || notes.length === 0) return;

            const notesContainer = document.getElementById(
                `zone-notes-${zoneId}`,
            ) as HTMLElement | null;
            if (!notesContainer) {
                console.warn(
                    "displayZoneNotes: notes container not found for zone",
                    zoneId,
                );
                return;
            }

            const notesHtml = `
                <div class="font-medium mb-3 text-slate-300">Zone Notes:</div>
                <div class="space-y-2 notes-list">
                    ${notes
                        .map((note, index) => {
                            // For non-video notes just display content
                            const typeClass =
                                note.note_type && note.note_type.color_class
                                    ? note.note_type.color_class
                                    : "bg-gray-500";
                            const displayName =
                                note.note_type && note.note_type.display_name
                                    ? note.note_type.display_name
                                    : "";
                            // Put a placeholder for note content; we'll process it below
                            return `
                            <div class="note-row flex items-start gap-3">
                                <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium text-white ${typeClass}">${displayName}</span>
                                <div class="note-content text-base text-slate-300" data-note-index="${index}">${note.content}</div>
                            </div>
                        `;
                        })
                        .join("")}
                </div>
            `;

            // Replace content of notes container
            notesContainer.innerHTML = notesHtml;

            // Now process each note content element: convert raw URLs to thumbnails for video notes
            notes.forEach((note, index) => {
                const el = notesContainer.querySelector(
                    `.note-content[data-note-index="${index}"]`,
                ) as HTMLElement | null;
                if (!el) return;

                // If note_type indicates video, render thumbnail-only (no link text)
                if (note.note_type && note.note_type.name === "video") {
                    // Determine the URL from content: could be raw URL or an <a> anchor
                    let href = "";
                    // If content contains an anchor, try to extract href
                    try {
                        // Create a temporary div to parse HTML
                        const tmp = document.createElement("div");
                        tmp.innerHTML = note.content;
                        const a = tmp.querySelector("a");
                        if (a && a.getAttribute("href")) {
                            href = a.getAttribute("href");
                        } else {
                            // if no anchor, maybe the content is a plain URL text
                            const text = tmp.textContent
                                ? tmp.textContent.trim()
                                : "";
                            if (text && text.startsWith("http")) {
                                href = text;
                            }
                        }
                    } catch (e) {
                        console.warn(
                            "displayZoneNotes: failed to parse note content",
                            e,
                        );
                    }

                    const videoId = extractYouTubeId(href);
                    if (videoId) {
                        // clear existing content and append thumbnail-only element
                        el.innerHTML = "";
                        const thumb = createYouTubeThumbnail(videoId);
                        el.appendChild(thumb);
                    } else {
                        // Couldn't extract id — fallback to rendering content as link/text
                        el.innerHTML = note.content;
                    }
                } else {
                    // Non-video note: render HTML content (admin-controlled)
                    el.innerHTML = note.content;
                    // Style any links if present
                    const links = el.querySelectorAll("a");
                    links.forEach((link) => {
                        link.className =
                            "text-blue-400 hover:text-blue-300 underline";
                        link.target = "_blank";
                        link.rel = "noopener noreferrer";
                    });
                }
            });
        }

        // Rating system functions
        async function loadZoneRating(zoneId) {
            try {
                const response = await fetch(`/zones/${zoneId}/rating`);
                if (response.ok) {
                    const ratingData = await response.json();
                    updateRatingDisplay(zoneId, ratingData);
                    setupRatingInteractivity(zoneId);
                }
            } catch (error) {
                console.error("Error loading rating:", error);
                const ratingTextEl = document.getElementById(
                    `rating-text-${zoneId}`,
                ) as HTMLElement | null;
                if (ratingTextEl)
                    ratingTextEl.textContent = "Rating unavailable";
            }
        }

        function updateRatingDisplay(zoneId, ratingData) {
            const container = document.getElementById(
                `rating-container-${zoneId}`,
            ) as HTMLElement | null;
            const ratingText = document.getElementById(
                `rating-text-${zoneId}`,
            ) as HTMLElement | null;

            if (!container || !ratingText) return;

            // Update rating text
            if (ratingData.total_ratings > 0) {
                ratingText.textContent = `Average: ${ratingData.average_rating.toFixed(1)}/5 (${ratingData.total_ratings} rating${ratingData.total_ratings !== 1 ? "s" : ""})`;
            } else {
                ratingText.textContent = "No ratings yet";
            }

            // Highlight user's rating if they have one
            if (ratingData.user_rating) {
                highlightRating(zoneId, ratingData.user_rating, true);
            }
        }

        function setupRatingInteractivity(zoneId) {
            const container = document.getElementById(
                `rating-container-${zoneId}`,
            ) as HTMLElement | null;
            if (!container) return;
            const pickleButtons =
                container.querySelectorAll<HTMLButtonElement>(".pickle-rating");

            pickleButtons.forEach((button) => {
                const rating = parseInt(button.dataset.rating || "0");

                // Hover effects
                button.addEventListener("mouseenter", () => {
                    highlightRating(zoneId, rating, false);
                });

                button.addEventListener("mouseleave", () => {
                    // Reset to user's actual rating or no highlight
                    const currentUserRating = container.dataset.userRating;
                    if (currentUserRating) {
                        highlightRating(
                            zoneId,
                            parseInt(currentUserRating),
                            true,
                        );
                    } else {
                        clearRatingHighlight(zoneId);
                    }
                });

                // Click to submit rating
                button.addEventListener("click", async () => {
                    await submitRating(zoneId, rating);
                });
            });
        }

        function highlightRating(zoneId, rating, isPermanent) {
            const container = document.getElementById(
                `rating-container-${zoneId}`,
            ) as HTMLElement | null;
            if (!container) return;
            const pickleButtons =
                container.querySelectorAll<HTMLButtonElement>(".pickle-rating");

            pickleButtons.forEach((button, index) => {
                const img = button.querySelector("img");

                if (index < rating) {
                    // Highlight this pickle - full opacity
                    if (img) img.style.opacity = "1";
                } else {
                    // Keep transparent
                    if (img) img.style.opacity = "0.3";
                }
            });

            if (isPermanent) {
                container.dataset.userRating = rating.toString();
            }
        }

        function clearRatingHighlight(zoneId) {
            const container = document.getElementById(
                `rating-container-${zoneId}`,
            ) as HTMLElement | null;
            if (!container) return;
            const pickleButtons =
                container.querySelectorAll<HTMLButtonElement>(".pickle-rating");

            pickleButtons.forEach((button, index) => {
                const img = button.querySelector("img");

                // Reset to transparent state
                if (img) img.style.opacity = "0.3";
            });
        }

        async function submitRating(zoneId, rating) {
            try {
                const response = await fetch(`/zones/${zoneId}/rating`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ rating: rating }),
                });

                if (response.ok) {
                    const ratingData = await response.json();
                    updateRatingDisplay(zoneId, ratingData);
                    highlightRating(zoneId, rating, true);
                } else {
                    throw new Error("Failed to submit rating");
                }
            } catch (error) {
                console.error("Error submitting rating:", error);
                alert("Failed to submit rating. Please try again.");
            }
        }

        
    </script>
</Layout>
